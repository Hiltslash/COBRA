#!/usr/bin/env python3
from setproctitle import setproctitle

setproctitle("Cobra")
import os
import tkinter as Tk
from tkinter import messagebox
import subprocess
from os import system as syst
import sys
from time import sleep as wait
import shlex
def clear(): syst("clear")
variables = {"calresult" : 0}
current_line = 0
labels = {}
ifmet = False
inifbrackets = False
def say(argument):
    subprocess.run(["say", argument])
def checkvar(string):
    if "var" in string and type(string) == str:
        donotuse, important = parse(string)
        importants = variables[important]
        return importants
    else:
        return string
#Comment on line 15
def sysdial(message, type, resultstore):
    if type == "info":
        messagebox.showinfo(filename, message)
    elif type == "warning":
        messagebox.showwarning(filename, message)
    elif type == "error":
        messagebox.showerror(filename, message)
    elif type == "ayn":
        variables[resultstore] = messagebox.askyesno(filename, message)
    elif type == "askok":
        variables[resultstore] = messagebox.askokcancel(filename, message)
    else:
        raise SyntaxError("INCORRECT SYSTEMDIAL TYPE")
def ifcondition(condition, exresult):
    conditionvar = checkvar(condition)
    exresultvar = checkvar(exresult)
    global ifmet
    global inifbrackets
    if str(conditionvar) == str(exresultvar):
        ifmet = True
        inifbrackets = True
    else:
        ifmet = False
        inifbrackets = True
def goto():
    pass

def calculate(numberone, operation, numbertwo, storevariable):
    numberone = checkvar(numberone)
    numbertwo = checkvar(numbertwo)
    operation = checkvar(operation)
    try:
        numberone = int(numberone)
        numbertwo = int(numbertwo)
        if operation == "*":
            result = numberone * numbertwo
        elif operation == "/":
            result = numberone / numbertwo
        elif operation == "+":
            result = numberone + numbertwo
        elif operation == "-":
            result = numberone - numbertwo
        elif operation == "#":
            result = numberone ** numbertwo
        else:
            print(f"Operation not found ({operation}) VALID OPERATIONS: +,*,-,#,/.")
            result = None
        variables[storevariable] = result
    except ValueError:
        print("VALUE ERROR: PLEASE PROVIDE TWO INTEGERS")
        raise ValueError

def waittime(seconds):
    wait(int(seconds))
def show(argument):
    argument = checkvar(argument)
    print(argument)

def cvar(name, value):
    try:
        int(value)
    except ValueError:
        str(value)
    variables[name] = value

def takeinput(variable, message):
    variables[variable] = input(str(message))

def forloop(times, command, *arguments):
    for i in range(int(times)):
        commands[command](*arguments)
commands =  {
    "show" : show,
    "cvar" : cvar,
    "cal" : calculate,
    "clear" : clear,
    "input" : takeinput,
    "for" : forloop,
    "wait" : waittime,
    "if" : ifcondition,
    "goto" : goto,
    "systemsay" : say,
    "systemdial" : sysdial
}

if len(sys.argv) > 1:
    filename = sys.argv[1]
else:
    print("Error: No filename provided.")
    sys.exit(1)
if not filename.endswith('.coil'):
    print("Error: Cobra scripts must have a .coil extension.")
    sys.exit(1)

def parse(line):
    if len(line) > 0:
        if line[0] == ":":
            pass # This cannot happen, unless the script has an unidentified label.
        else:
            shlexedline = shlex.split(line)
            command = shlexedline[0]
            try:
                if shlexedline[2]:
                    arguments = shlexedline[1:]
                else:
                    arguments = shlexedline[1]
            except IndexError:
                arguments = shlexedline[1]
            return command, arguments

def main():
    global current_line
    global inifbrackets
    global ifmet
    with open(filename, "r") as file:
        scriptlines = file.readlines()
    while current_line < len(scriptlines):
        line = scriptlines[current_line].strip()
        if not line:
            current_line += 1
            continue
        if line.lower() == ":end":
            inifbrackets = False
            current_line += 1
            continue
        if inifbrackets and not ifmet:
            current_line += 1
            continue

        command, arguments = parse(line)
        if command in commands:
            try:
                if command.lower() == "show":
                    show(arguments)
                elif command.lower() == "input":
                     takeinput(*arguments)
                elif command.lower() == "for":
                    forloop(*arguments)
                elif command.lower() == "wait":
                    waittime(arguments)
                elif command.lower() == "if":
                    ifcondition(*arguments)
                elif command.lower() == "cvar":
                    cvar(*arguments)
                elif command.lower() == "cal":
                     calculate(*arguments)
                elif command.lower() == "clear":
                        clear()
                elif command.lower() == "systemsay":
                    say(arguments)
                elif command.lower() == "goto":
                    current_line = int(arguments)
                    continue
                elif command.lower() == "systemdial":
                    sysdial(*arguments)
            except TypeError as e:
                raise TypeError
        else:
            print(f"Syntax error: {command} command not found in base.")
        current_line += 1
main()