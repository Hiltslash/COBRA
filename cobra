#!/usr/bin/env python3.12
import os
import sys
import shlex
from pathlib import Path
from time import sleep


class Runtime:
    def __init__(self):
        self.variables = {}
        self.keywords = {}
        self.functions = []
        self.commands = []
        self.isDefFunc = False
        self.isDefIf = False

    def createVariable(self, key, vartype, value):
        self.variables[key] = {"vartype" : vartype, "value" : value}


runtime = Runtime()


class Command:
    def __init__(self, name, arguments, exec_code):
        self.name = name
        self.arguments = arguments
        self.exec = exec_code
        runtime.commands.append(self)

    def execute(self, *passedArguments):
        # Replace variable references like @var with their actual value
        resolved_args = []
        for arg in passedArguments:
            if arg.startswith("@"):
                varname = arg[1:]
                if varname in runtime.variables:
                    resolved_args.append(runtime.variables[varname]["value"])
                else:
                    print(f"[RUNTIME ERROR] Variable '{varname}' not found.")
                    return
            else:
                resolved_args.append(arg)

        if len(resolved_args) >= 1:  # Allow multiple arguments
            self.exec(*resolved_args)
        else:
            print(f"ERROR: command {self.name} expects at least 1 argument but got {len(resolved_args)}")

        
if True: #Helper functions for more complex commands

    def math(n1, operator, n2, resvar):
        try:
            n1 = float(n1)
            n2 = float(n2)
        except ValueError:
            print("Error: n1 and n2 must be numbers.")
            return

        if operator == '+':
            result = n1 + n2
        elif operator == '-':
            result = n1 - n2
        elif operator == '*':
            result = n1 * n2
        elif operator == '/':
            if n2 == 0:
                print("[Error]: Division by zero")
                return
            result = n1 / n2
        elif operator == '%':
            if n2 == 0:
                print("[Error]: Modulo by zero")
                return
            result = n1 % n2
        elif operator == '^':
            result = n1 ** n2
        else:
            print("[Error]: Unsupported operator")
            return

        runtime.createVariable(resvar, "int", result)

    def fh(mode, f, *other):
        if mode == "c":
                with open(f, "w") as file:
                    ...
        if os.path.exists(f):
            if mode == "a":
                content = other[0]
                with open(f, "a") as file:
                    file.write(f"\n{content}")
            elif mode == "o":
                content = other[0]
                with open(f, "w") as file:
                    file.write(content)
            elif mode == "e":
                with open(f, "w") as file:
                    file.write("")
            elif mode == "d":
                os.remove(Path.cwd() / f)
            

if True: #Commands
    if True: #I/O

        show = Command(
            "show",
            ["...messages"],  # Allow for multiple arguments
            lambda *args: print(" ".join(str(arg) for arg in args))
        )

        inp = Command(
            "termIN",
            ["message", "resvar"],
            lambda message, resvar: (
                runtime.createVariable(resvar, "string", input())
            )
        )

    if True: #Math

        calc = Command(
            "math",
            ["n1", "operator", "n2", "resvar"],
            lambda n1, operator, n2, resvar: 
                math(n1, operator, n2, resvar)
        )

    if True: #Variables

        cvar = Command(
            "cvar",
            ["name", "vtype", "value"],
            lambda name, vtype, value:
                runtime.createVariable(name, vtype, value)
        )
    
    if True: #File Handling
    
        mf = Command(
            "createFile",
            ["name"],
            lambda name:
                fh("c", name)
        )

        af = Command(
            "appendToFile",
            ["file", "content"],
            lambda file, content:
                fh("a", file, content)
        )

        ovf = Command(
            "overwriteFile",
            ["file", "content"],
            lambda file, content:
                fh("o", file, content)
        )

        ef = Command(
            "eraseFile",
            ["file"],
            lambda file:
                fh("e", file)
        )

        df = Command(
            "deleteFile",
            ["file"],
            lambda file:
                fh("d", file)
        )

    if True: #Misc
        wait = Command(
            "wait",
            ["ms"],
            lambda ms:
                sleep(int(ms) / 1000)
        )


if True: #Sys-argv detection
    if len(sys.argv) > 1:
        filename = sys.argv[1]
    else:
        print("Error: No filename provided.")
        sys.exit(1)

    if not filename.endswith('.coil'):
        print("Error: Cobra scripts must have a .coil extension.")
        sys.exit(1)


def main(): #Main function that loops through lines of code and executes them
    with open(filename, "r") as file:
        scriptlines = file.read().splitlines()

    for line in scriptlines:
        if not line.strip():  # Skip blank lines
            continue
        if line.startswith("//") or line.startswith("#"):
            continue

        sectors = shlex.split(line)

        #Mid-line comment detection
        filtered_sectors = []
        for s in sectors:
            if s.startswith("//") or s.startswith("#"):
                break  # Ignore everything after this
            filtered_sectors.append(s)
        if not filtered_sectors:
            continue
        command_name = filtered_sectors[0]
        arguments = filtered_sectors[1:]

        # Check for commands if it's not a keyword
        cmd_obj = next((c for c in runtime.commands if c.name == command_name), None)
        if cmd_obj:
            try:
                cmd_obj.execute(*arguments)
            except Exception as e:
                print(f"[RUNTIME ERROR] {e}")
                sys.exit(1)
        else:
            print(f"[ERROR] Unknown command or keyword: {command_name}")
            sys.exit(1)

main()
